% \documentclass[12pt]{ociamthesis}  % default square logo
\documentclass[12pt]{article}  % default square logo

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage[margin=2.8cm]{geometry}
\usepackage{setspace}
\usepackage{mathptmx} % Times font
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{framed}
\usepackage[colorlinks=true]{hyperref}

% code listing
\usepackage{listings}
\usepackage{xcolor}

% packages for drawing
\usepackage{tikz}
\usetikzlibrary{graphs}     % create graphs
\usetikzlibrary{arrows}

%% set code styles

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}


\onehalfspacing{}

\title{Case study: the board game Go}

\author{Ólafur Páll Geirsson  \quad \quad  Fengyun Liu}

%end the preamble and start the document
\begin{document}

\maketitle

\begin{abstract}
    The ancient Chinese board game Go has fascinated computer scientists and mathematicians for its enormous state space.
    In this case study, we implemented Go in Leon and Scala with the objective to answer the question: how practical is it to use Leon to program a correct implementation of Go?
    Our experiments reveal that it is indeed useful to to annotate a Scala codebase with Leon verification conditions.
    Still, we consider that Leon has plenty of room for improvement to make it easier for a programmer to verify non-trivial properties about her programs.
\end{abstract}

% \tableofcontents

\section{Contributions}
The main contributions of this project are the following:
\begin{itemize}
    \item We found a productive developer workflow combining Leon verification and Scala
        unit testing (see Section~\ref{sec:Developer_workflow}).
    \item We did a minor case study of the connected component algorithm (see Section~\ref{sec:Connected_Component}).
    \item We verified several properties of our implementation of the board game Go (see Section~\ref{sec:Verification}).
    \item We identified a few issues in Leon, which we reported on Github (see Section~\ref{sec:Bugs}).
\end{itemize}

\section{Developer workflow} % (fold)
\label{sec:Developer_workflow}
Although we wanted to verify certain properties in Leon, we set the requirement for our project that we also wanted to be able to run our Go program with Scala in the command line.
This requirement forced us to set up a productive developer workflow that executed both the Scala and Leon versions of our code.

A common developer workflow with Scala is to have an \emph{sbt} shell open inside your project and execute the command \texttt{$\sim$test}.
On every file save, sbt will then recompile your project and execute your unit tests.
The benefit to this workflow is that the code-compile-run-debug cycle is as short as possible.
When starting on our project, we quickly realized that we missed this productive workflow.

We were able to accomplish the same productive workflow with Leon by making a few minor changes to our \texttt{build.sbt} file.
The key idea was to make a new sbt task, which we named \emph{verify}.
The verify task was defined with the following snippet of code in our \texttt{build.sbt} definitions.
\lstinputlisting{code/build.sbt}
This snippet adds the bash script \texttt{leonVerify.sh} to the files that are watched by sbt.
The implementation of the task simply runs the unit tests and then if the all unit tests compile and pass, we run the Leon verification.
The contents of the \texttt{leonVerify.sh} script is then:
\lstinputlisting{code/leonVerify.sh}
Instead of running \texttt{$\sim$test} in the sbt shell, we now ran \texttt{$\sim$verify}.
Whenever we modified our code or tweaked the parameters supplied to Leon in the \texttt{leonVerify.sh} script, the task was re-executed.

This setup greatly helped us keep the codebase compatible with both Scala and Leon.
Although Leon aims to be a strict subset of Scala, there are a few minor discrepancies between the two langauges.
Such an example includes \texttt{Nil[T]()}, which compiles with Leon but does not compile with Scala since \texttt{scala.Nil} is a singleton type.
Moreover, there are many methods in Scala collection libraries that are yet to be added to the Leon collections.
Some additional benefits to using this developer workflow include:
\begin{itemize}
    \item Compilation errors are detected faster with scalac, due to sbt's incremental compilation.
    \item Obvious bugs are caught faster by the unit tests than verification.
    \item Not so obvious corner cases were detected by our unit tests while Leon timed out.
    \item Obviously non-terminating programs failed the unit tests before verification was executed.
\end{itemize}
% section Developer workflow (end)

\section{Connected Component} % (fold)
\label{sec:Connected_Component}

% section Connected Component (end)

\section{Verification} % (fold)
\label{sec:Verification}

% section Verification (end)

The design of the game ensures that no player can violate the game rule. We
only need to verify that the game rule implementation is correct. We are able
to verify following properties of the game:

\begin{itemize}
\item Can’t place cell outside the board
\item Can’t place on occupied cell
\item The board size remains unchanged
\end{itemize}

In the verification of game rules, the most difficult part is the \emph{depth
first search} of connected component. The verification result of the DFS
algorithm is as follows:

\begin{itemize}
\item All points are connected  --- FAIL
\item The component is maximal  --- FAIL
\item The root is in the component --- SUCCESS
\item All points are of same color --- FAIL
\item All points are on the board --- SUCCESS
\end{itemize}

The difficulty lies in that the relation \emph{connected} is transitive, but
Leon knows nothing about that. The DFS algorithm looks like follows:

\lstinputlisting{code/cc.scala}


\section{Github issues} % (fold)
\label{sec:Bugs}
We reported the following issues on Github:
\begin{itemize}
        \foreach\issue\ in {94,98,99,103,105,106,107}
    {\item \href{https://github.com/epfl-lara/leon/issues/\issue}{\#\issue}}
\end{itemize}


% section Bugs (end)


\section{Conclusion}

During the project, we learned some lessons about Leon and verification in
general.

First, we find that \emph{class state invariants} are helpful, which is a nice
feature to have in Leon.  For example, in the class Point, we’d like very
instance of Point to satisfy the pre-condtion. Unfortunately, we have to
duplicate the requirement in almost every usage of Point.

\lstinputlisting{code/class-invariant.scala}

Class state invariant not only avoids duplicate code, but also enables
programmers to think about verification at a higher level of abstraction, and
it’s more natural with the object-oriented mind-set.

Second, we find that Leon can be improved to reduce surprises for developers.
Following are two examples.

\begin{itemize}
    \item Unit tests help against termination
\end{itemize}

\lstinputlisting{code/surprise.scala}

\begin{itemize}
    \item Publish leon dummies to Maven.
\end{itemize}

\end{document}
