% \documentclass[12pt]{ociamthesis}  % default square logo
\documentclass[12pt]{article}  % default square logo

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage[margin=2.8cm]{geometry}
\usepackage{setspace}
\usepackage{mathptmx} % Times font
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{framed}
\usepackage[colorlinks=true]{hyperref}

% code listing
\usepackage{listings}
\usepackage{xcolor}

% packages for drawing
\usepackage{tikz}
\usetikzlibrary{graphs}     % create graphs
\usetikzlibrary{arrows}

%% set code styles

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}


\onehalfspacing{}

\title{Case study: the board game Go}

\author{Ólafur Páll Geirsson  \quad \quad  Fengyun Liu}

%end the preamble and start the document
\begin{document}

\maketitle

\begin{abstract}
    The ancient Chinese board game Go has fascinated computer scientists and mathematicians for its enormous state space.
    In this case study, we implemented Go in Leon and Scala with the objective to answer the question: how practical is it to use Leon to program a correct implementation of Go?
    Our experiments reveal that it is indeed useful to to annotate a Scala codebase with Leon verification conditions.
    Still, we consider that Leon has plenty of room for improvement to make it easier for a programmer to verify non-trivial properties about her programs.
\end{abstract}

\tableofcontents

\section{Contributions}
Our main contributions in this project are the following:
\begin{itemize}
    \item Set up a productive developer workflow combining Leon verification
        and Scala unit testing (see Section~\ref{sec:Developer_workflow}).
    \item A case study of the connected component algorithm (see Section~\ref{sec:Connected_Component}).
    \item Verified several properties of our implementation of the board game Go (see Section~\ref{sec:Verification}).
    \item Identified a few issues in Leon and reported on Github (see Section~\ref{sec:Bugs}).
\end{itemize}

\section{Design} % (fold)
\label{sec:Design}

% section Design (end)
Various iterations.

\subsection{Game}

Because Leon doesn't support side effects, the first task of the project is to
make a purely functional design. To achieve this goal, we modeled the game as a
finite list of board states as follows:

\lstinputlisting{code/board.scala}

The type \emph{Cell} represents the color of the stone, it's defined as
follows:

\lstinputlisting{code/cell.scala}

The type \emph{Step} represents an action that can be taken by the player, it's
defined as follows:

\lstinputlisting{code/step.scala}

The type \emph{PlayerType} represents the two sides of a game, it's defined as
follows:

\lstinputlisting{code/player-type.scala}

\subsection{Rules}

Each game has rules that should be observed by the players. Inside the world of
Go, there're several popular rules, such as Chinese rule, Japanese rule, etc.
In order to decouple rules from the game, we implemented the rules in
\emph{RuleEngine}, so that it's possible to implement different sets of rules.
The object \emph{RuleEngine} is defined as follows:

\lstinputlisting{code/rule-engine.scala}

There could be several types of move errors, which are defined as follows:

\lstinputlisting{code/move-error.scala}

\subsection{Player}

There are several types of players in the game, such as computer players, human
players, etc. We impose that all kinds of player should implement following
interface:

\lstinputlisting{code/player.scala}

When the method \emph{move} is called, the player should decide an action based
on the given state of the game. Currently we implemented three types of players
in the game:

\begin{itemize}
\item HumanPlayer: make a move from user input in the console
\item ComputerPlayer: make a move based on MinMax algorithm
\item RandomPlayer: make a random move
\end{itemize}

\subsection{Driver}

The game is driven by the driver. An example driver is as follows:

\lstinputlisting{code/driver.scala}

With the driver defined as above, it's easy to run a game like following:

\lstinputlisting{code/run.scala}

\section{Developer workflow} % (fold)
\label{sec:Developer_workflow}
We set the requirement for our project that we wanted to be able to run our Go program with Scala in the command line.
This requirement for

% section Developer workflow (end)

\section{Connected Component} % (fold)
\label{sec:Connected_Component}

% section Connected Component (end)

\section{Verification} % (fold)
\label{sec:Verification}

% section Verification (end)

The design of the game ensures that no player can violate the game rule. We
only need to verify that the game rule implementation is correct. We are able
to verify following properties of the game:

\begin{itemize}
\item Can’t place cell outside the board
\item Can’t place on occupied cell
\item The board size remains unchanged
\end{itemize}

In the verification of game rules, the most difficult part is the \emph{depth
first search} of connected component. The verification result of the DFS
algorithm is as follows:

\begin{itemize}
\item All points are connected  --- FAIL
\item The component is maximal  --- FAIL
\item The root is in the component --- SUCCESS
\item All points are of same color --- FAIL
\item All points are on the board --- SUCCESS
\end{itemize}

The difficulty lies in that the relation \emph{connected} is transitive, but
Leon knows nothing about that. The DFS algorithm looks like follows:

\lstinputlisting{code/cc.scala}


\section{Github issues} % (fold)
\label{sec:Bugs}
We reported the following issues on Github:
\begin{itemize}
        \foreach\issue\ in {94,98,99,103,105,106,107}
    {\item \href{https://github.com/epfl-lara/leon/issues/\issue}{\#\issue}}
\end{itemize}


% section Bugs (end)
\section{Lessons Learned}

During the project, we learned some lessons about Leon and verification in
general.

First, we find that \emph{class state invariants} are helpful, which is a nice
feature to have in Leon.  For example, in the class Point, we’d like very
instance of Point to satisfy the pre-condtion. Unfortunately, we have to
duplicate the requirement in almost every usage of Point.

\lstinputlisting{code/class-invariant.scala}

Class state invariant not only avoids duplicate code, but also enables
programmers to think about verification at a higher level of abstraction, and
it’s more natural with the object-oriented mind-set.

Second, we find that Leon can be improved to reduce surprises for developers.
Following are two examples.

\begin{itemize}
    \item Unit tests help against termination
\end{itemize}

\lstinputlisting{code/surprise.scala}

\subsection{Suggestions} % (fold)
\label{sub:Suggestions}

\begin{itemize}
    \item Publish leon dummies to Maven.
\end{itemize}

% subsection Suggestions (end)



\end{document}
